import os
import re
import subprocess
import time
import glob
import hashlib
import shutil

TOOL_CHOICE = None
INPUT_SIZES = None
SOURCE_DIRECTORY_MALWARE = None
SOURCE_DIRECTORY_BENIGN = None
CURATED_APK_DIRECTORY = None
DESTINATION_DIRECTORY = None
REPACKAGED_PAIRS_FILE = None
TIMEOUT_DELAY = None
STRACE_ARGS = None
CONTAINERIP="0.0.0.0" #will need to change this

def exitScript():
    print("Exiting properly")


def createContainer():
    subprocess.run(["docker", "run", "-d", "-e", "ADBKEY=$(cat ~/.android/adbkey)", "--device", "/dev/kvm", "--publish", "8554:8554/tcp", "--publish",
                   "5555:5555/tcp", "--name", "android-container", "us-docker.pkg.dev/android-emulator-268719/images/30-google-x64:30.1.2"], stdout=subprocess.DEVNULL)
    output = subprocess.run(
        ["docker", "inspect", "-f", "{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}", "android-container"], capture_output=True, text=True)
    CONTAINERIP = output.stdout.strip()
    time.sleep(5)
    subprocess.run(
        ["adb", "connect", f"{CONTAINERIP}:5555"], stdout=subprocess.DEVNULL)
    subprocess.run(["adb", "-s", f"{CONTAINERIP}:5555",
                   "wait-for-device"], stdout=subprocess.DEVNULL)

    while True:
        output = subprocess.run(["adb", "-s", f"{CONTAINERIP}:5555", "shell",
                                "getprop", "sys.boot_completed"], capture_output=True, text=True)
        if output.stdout.strip() == "1":
            break

        print("Still waiting for boot, retrying in 10 sec...")
        time.sleep(10)


def trace_apk_monkey(apk, input_events, ip_address):
    local_hash = os.path.basename(apk).replace('.apk', '')
    packname = get_package_name(apk)

    print("Installing apk via adb ... ")
    subprocess.run(["adb", "-s", f"{ip_address}:5555", "install", "-g", apk])
    
    print("Tracing ... ")
    destination_directory = "path/to/destination/directory"  # Specify the destination directory
    monkdata_file = os.path.join(destination_directory, f"{input_events}-{local_hash}.monkdata")
    trace_file = os.path.join(destination_directory, f"{input_events}-{local_hash}.trace")
    with open(monkdata_file, "w") as monkdata, open(trace_file, "w") as trace:
        subprocess.run(["adb", "-s", f"{ip_address}:5555", "shell", "strace", STRACE_ARGS,
                        "/system/bin/sh", "/system/bin/monkey", "-p", packname, "-v", input_events],
                       stdout=monkdata, stderr=trace)

    print("done")

def get_package_name(apk):
    output = subprocess.run(["aapt", "dump", "badging", apk], capture_output=True, text=True)
    package_name = re.search(r"package:\s+name='(.*?)'", output.stdout)
    if package_name:
        return package_name.group(1)
    else:
        raise ValueError("Failed to extract package name from APK")

def trace_apk_droidbot(apk, input_events, ip_address):
    print("Preparing trace with droidbot...")
    subprocess.run(["sudo", "droidbot", "-a", apk, "-d", f"{ip_address}:5555", "-o", "output_dir",
                    "-count", input_events, "-keep_env", "-is_emulator"])
    move_output()
    print("done")

def move_output(destination_directory):
    to_move = "./output_dir/logcat.txt"
    shutil.move(to_move, destination_directory)
    shutil.rmtree("./output_dir")

def traceAPK(apk, input_events, container_ip):
    if TOOL_CHOICE == 1:
        print("You chose to continue with Monkey")
        trace_apk_monkey(apk, input_events, container_ip)
    elif TOOL_CHOICE == 2:
        print("You chose to continue with DroidBot")
        trace_apk_droidbot(apk, input_events, container_ip)
    else:
        print("Error on the choice of the tool")


def processData():
    print("Testing apks...")
    print()
    for apk in glob.glob(f"{CURATED_APK_DIRECTORY}/*.apk"):
        print(f"Starting tests for apk: {apk}...")
        for input_number in INPUT_SIZES:
            print(f"Test {input_number}...")
            if checkFiles(apk, input_number):
                print("Skipped")
                continue

            createContainer()
            traceAPK(apk, input_number, CONTAINERIP)


def mainBody():
    prepareData()
    processData()
    exitScript()


def prepareData():
    print()
    print("Preparing data...")
    print()
    createDatabaseIfNeeded()
    if not os.path.exists(CURATED_APK_DIRECTORY):
        os.mkdir(CURATED_APK_DIRECTORY)
    for local_dir in glob.glob(f"{SOURCE_DIRECTORY_MALWARE}/*/") + glob.glob(f"{SOURCE_DIRECTORY_BENIGN}/*/"):
        print(f"Preparing data in folder {local_dir}...")
        for file in glob.glob(f"{local_dir}*"):
            hash_value = hashlib.sha256(open(file, 'rb').read()).hexdigest()
            if not os.path.exists(os.path.join(CURATED_APK_DIRECTORY, f"{hash_value}.apk")):
                shutil.copy(file, os.path.join(
                    CURATED_APK_DIRECTORY, f"{hash_value}.apk"))


def checkFiles(apk, input_number):
    apk_hash = hashlib.sha256(open(apk, 'rb').read()).hexdigest()
    pair_file = f"{apk_hash}-{input_number}.txt"
    return os.path.exists(os.path.join(DESTINATION_DIRECTORY, pair_file))


def createDatabaseIfNeeded():
    if not os.path.exists(DESTINATION_DIRECTORY):
        os.mkdir(DESTINATION_DIRECTORY)


def parseRepackagedPairsFile():
    pairs = []
    with open(REPACKAGED_PAIRS_FILE, 'r') as file:
        lines = file.readlines()
        for line in lines:
            apk1, apk2 = line.strip().split(',')
            pairs.append((apk1, apk2))
    return pairs


def processRepackagedPairs():
    print("Processing repackaged pairs...")
    print()
    pairs = parseRepackagedPairsFile()
    for pair in pairs:
        apk1, apk2 = pair
        print(f"Testing repackaged pair: {apk1} - {apk2}")
        for input_number in INPUT_SIZES:
            print(f"Test {input_number}...")
            if checkFiles(apk1, input_number) and checkFiles(apk2, input_number):
                print("Skipped")
                continue

            createContainer()
            traceAPK(apk1, input_number, CONTAINERIP)
            traceAPK(apk2, input_number, CONTAINERIP)


def main():
    mainBody()
    if REPACKAGED_PAIRS_FILE is not None:
        processRepackagedPairs()
    exitScript()


if __name__ == '__main__':
    main()
