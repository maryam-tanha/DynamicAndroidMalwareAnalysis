import subprocess
import time
import re
import sys
import os
import pathlib


def install_application(apk_path):
    """
        Uses ADB to install an APK on an Android emulator (adb install <apk_path>).
        BASH CMD: `adb install <apk_path>`
    """
    subprocess.call(["adb", "-s", "emulator-5556", "install", apk_path])


def simulate_user_interactions(package_name, duration, output_file):
    """
    User Interaction Simulation:

    Simulates user interactions on the installed app using the Monkey tool.
    Monkey command: adb shell monkey -p <package_name> ... <duration>
    Outputs interaction details to a text file
    :param package_name: APK package name
    :param duration: 300 seconds
    :param output_file: path to the strace output text file
    """
    with open(output_file, "w") as file:
        """
        BASH CMD:
        `adb shell monkey -p <package_name> -v --throttle 200 --pct-touch 45 --pct-motion 20 --pct-trackball 10
        --pct-syskeys 5 --pct-appswitch 10 --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes
        -s 1234 -v -v -v <duration>`
        """

        process = subprocess.Popen(
            [
                "adb",
                "-s", "emulator-5556",
                "shell",
                "monkey",
                "-p",
                package_name,
                "-v",
                "--throttle",
                "200",
                "--pct-touch",
                "45",
                "--pct-motion",
                "20",
                "--pct-trackball",
                "10",
                "--pct-syskeys",
                "5",
                "--pct-appswitch",
                "10",
                "--ignore-crashes",
                "--ignore-timeouts",
                "--ignore-security-exceptions",
                "--monitor-native-crashes",
                "-s",
                "1234",
                "-v",
                "-v",
                "-v",
                str(duration),
            ],
            stdout=subprocess.PIPE,
        )

        # Read the output and write it to the file
        while True:
            output = process.stdout.readline()
            if not output:
                break
            file.write(output.decode().strip() + "\n")


def list_files(path):
    """
    Lists all APK files in a specified directory.
    :param path: directory path
    :return: list of files
    """
    files_list = []
    for apk_file in os.listdir(path):
        file_path = os.path.join(path, apk_file)
        if os.path.isfile(file_path):
            temp_path = pathlib.Path(file_path)
            if temp_path.suffix == '.apk':
                files_list.append(file_path)
    return files_list


def create_directories(package_name):
    """
    Creates directories for storing analysis results based on the package name
    :param package_name: APK package name
    :return: output file path for monkeys logs, APK dirrectory path
    """

    parent_dir = "/media/mary/External HD/prod_logs/AZLogs"  # Update this based on your directory structure
    output_file_monkey = f"monkey_{package_name}.txt"

    # Create the directory path
    directory_path_apk = os.path.join(parent_dir, package_name)

    if not os.path.exists(directory_path_apk):
        os.makedirs(directory_path_apk)

    # Create the full output file path
    output_file_path_monkey = os.path.join(
        directory_path_apk, output_file_monkey)

    return (output_file_path_monkey, directory_path_apk)


def get_package_name(apk_path):
    """
    Retrieves the package name of an APK using the AAPT tool (aapt dump badging <apk_path>).
    :param apk_path: APK Path
    :return: string APK package name
    """
    # BASH CMD: `aapt dump badging <apk_path>`
    aapt_output = subprocess.check_output(
        ["aapt", "dump", "badging", apk_path]
    ).decode()
    package_name_match = re.search(r"package: name='([^']*)'", aapt_output)
    if package_name_match:
        return package_name_match.group(1)
    else:
        raise ValueError("Failed to retrieve package name from APK file.")


def start_strace_monkey(package, monkey_log_file, log_file, log_file_destination):
    """
    Initiates strace to trace system calls and Monkey for user interactions.
    Monitors and pulls strace logs from the emulator.
    Saves Monkey logs to a local file.

    """
    # Start the main activity of the application
    subprocess.call(
        [
            "adb",
            "-s", "emulator-5556",
            "shell",
            "monkey",
            "-p",
            package,
            "-c",
            "android.intent.category.LAUNCHER",
            "1",
        ]
    )

    time.sleep(5)
    process = subprocess.Popen(["adb", "-s", "emulator-5556", "shell", "pidof", package], stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    print(f"pidof Output: {stdout}")

    # Check the return code to see if the command was successful
    if process.returncode == 0:
        # The command was successful
        pid = stdout.decode().strip()
        if pid:
            # Start strace
            subprocess.Popen(["adb", "-s", "emulator-5556", "shell", "strace", "-p", pid, "-o", log_file, "-f", "-ttt"])

            simulate_user_interactions(package, 300, monkey_log_file)

            # Start adb monkey for 2 minutes - replaced with the command on line 136
            # subprocess.call(["adb","-s", "emulator-5556", "shell", "monkey", "-p", package, "--throttle", "200", "--ignore-crashes", "--ignore-timeouts", "180"])

            # Close the app
            subprocess.call(["adb", "-s", "emulator-5556", "shell", "am", "force-stop", package])

            # Sleep for a moment to ensure strace finishes
            time.sleep(3)

            # Kill strace
            subprocess.call(["adb", "-s", "emulator-5556", "shell", "pkill", "strace"])

            # Extract the logFile to local storage
            subprocess.call(["adb", "-s", "emulator-5556", "pull", log_file, log_file_destination])

            # Remove the log file from sdcard storage
            subprocess.call(["adb", "-s", "emulator-5556", "shell", "rm", log_file])
    else:
        # The command encountered an error
        print(f"Error: Could not retrieve the process ID for package {package}.")

    # Uninstall the APK file
    subprocess.call(["adb", "-s", "emulator-5556", "shell", "pm", "uninstall", package])


# Main execution
# Iterates through a specified directory of APK files.
# Installs, analyzes, and extracts logs for each APK.
# Outputs processing statistics.
if __name__ == "__main__":
    apk_files_list = []
    paths = [
        "/media/mary/External HD/Androzoo-APKs/AndrozooBenign1001-1800-20230918T041243Z-001/AndrozooBenign1001-1800",
    ]

    for path in paths:
        apk_files_list.extend(list_files(path))

    subprocess.call(["adb", "-s", "emulator-5556", "root"])

    total_apks = len(apk_files_list)
    print("Total APKs to process: " + str(total_apks))

    time.sleep(3)
    idx = 0

    for apk_file in apk_files_list:
        try:
            if apk_file.endswith(".apk"):
                package_name = get_package_name(apk_file)
                if package_name:
                    idx += 1
                    output_file_path_strace = f"/sdcard/strace_{package_name}.txt"
                    output_file_path_monkey, output_folder_path_strace = create_directories(package_name)
                    install_application(apk_file)
                    start_strace_monkey(package_name, output_file_path_monkey, output_file_path_strace,
                                        output_folder_path_strace)
                else:
                    print(f"Error: Could not retrieve the package name from APK file {apk_file}")
            else:
                print(f"Error: {apk_file} is not an APK file.")
        except Exception as e:
            print(f"Error: An error occurred for {apk_file}: {str(e)}")
        rem = total_apks - idx
        print("APK Files Processed: " + str(idx) + "\n APK Files remaining: " + str(rem))
